{"version":3,"file":"passwordlessclient.min.mjs","sources":["../src/main.js"],"sourcesContent":["ï»¿/**\r\n * A client for the https://passwordless.dev API that allows webdevelopers to add WebAuthn with minimal coding.\r\n *\r\n * @export\r\n * @class PasswordlessClient\r\n */\r\nexport class PasswordlessClient {\r\n    config = {\r\n        apiUrl: \"https://api.passwordless.dev/\",\r\n        apiKey: \"\",\r\n        Origin: location.origin,\r\n        RPID: location.hostname\r\n    }\r\n    constructor(config) {\r\n        this.config = { ...this.config, ...config }\r\n    }\r\n\r\n    /**\r\n    * Returns true if the device has builtin \"platform\" authenticator (Windows Hello/faceid/fingerprint etc)\r\n    */\r\n    static async isEnabledOnDevice() {\r\n        return await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\r\n    }\r\n\r\n    static isSupportedByBrowser() {\r\n        if (window.PublicKeyCredential === undefined ||\r\n            typeof window.PublicKeyCredential !== \"function\") {\r\n                return false;\r\n            }\r\n\r\n            return true;\r\n    }\r\n\r\n    CheckSupport() {\r\n        if(!PasswordlessClient.isSupportedByBrowser()){\r\n            throw new Error(\"WebAuthn and PublicKeyCredentials are not supported on this browser/device\");\r\n        }\r\n    }\r\n    \r\n\r\n    /**\r\n     * Register a new credential to a user\r\n     *\r\n     * @param {*} token Token generated by your backend and the passwordless api.\r\n     * @memberof PasswordlessClient\r\n     */\r\n    async register(token) {\r\n        this.CheckSupport();\r\n        let options;\r\n        let session;\r\n\r\n        try {\r\n            var { data, sessionId } = await this.registerBegin(token);\r\n            options = data;\r\n            session = sessionId;\r\n\r\n        } catch (e) {\r\n            console.error(\"Failed during register/begin\");\r\n            throw e;\r\n        }\r\n\r\n        // Turn the challenge back into the accepted format of padded base64\r\n        options.challenge = coerceToArrayBuffer(options.challenge);\r\n        // Turn ID into a UInt8Array Buffer for some reason\r\n        options.user.id = coerceToArrayBuffer(options.user.id);\r\n\r\n        options.excludeCredentials = options.excludeCredentials.map((c) => {\r\n            c.id = coerceToArrayBuffer(c.id);\r\n            return c;\r\n        });\r\n\r\n        if (options.authenticatorSelection.authenticatorAttachment === null) options.authenticatorSelection.authenticatorAttachment = undefined;\r\n\r\n        let newCredential;\r\n        try {\r\n            newCredential = await navigator.credentials.create({\r\n                publicKey: options\r\n            });\r\n        } catch (e) {\r\n            // todo friendlier and more helpful error detection\r\n            var msg = \"Failed during credentials.create in browser. One reason could be because the username is already registered with your authenticator. Please change username or authenticator.\"\r\n            console.warn(msg, e);\r\n            throw e;\r\n        }\r\n\r\n        try {\r\n            await this.registerComplete(newCredential, session);\r\n        } catch (e) {\r\n            console.warn(\"Failed during register/complete\", e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Internal function\r\n     */\r\n    async registerBegin(token) {\r\n        const response = await fetch(this.config.apiUrl + 'register/begin', {\r\n            method: 'POST',\r\n            body: JSON.stringify({\r\n                token: token,\r\n                ...this._params()\r\n            }),\r\n            headers: {\r\n                'Accept': 'application/json',\r\n                \"Content-Type\": \"application/json\",\r\n                'ApiKey': this.config.apiKey\r\n            }\r\n        });\r\n\r\n        let data = await response.json();\r\n\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Internal function\r\n     */\r\n    async registerComplete(newCredential, sessionId) {\r\n        \r\n        // Move data into Arrays incase it is super long\r\n        let attestationObject = new Uint8Array(newCredential.response.attestationObject);\r\n        let clientDataJSON = new Uint8Array(newCredential.response.clientDataJSON);\r\n        let rawId = new Uint8Array(newCredential.rawId);\r\n\r\n        const data = {\r\n            id: newCredential.id,\r\n            rawId: coerceToBase64Url(rawId),\r\n            type: newCredential.type,\r\n            extensions: newCredential.getClientExtensionResults(),\r\n            response: {\r\n                AttestationObject: coerceToBase64Url(attestationObject),\r\n                clientDataJson: coerceToBase64Url(clientDataJSON)\r\n            }\r\n        };\r\n\r\n        const response = await fetch(this.config.apiUrl + 'register/complete', {\r\n            method: 'POST',\r\n            body: JSON.stringify({\r\n                response: data,\r\n                sessionId, sessionId,\r\n                ...this._params()\r\n            }),\r\n            headers: {\r\n                'Accept': 'application/json',\r\n                \"Content-Type\": \"application/json\",\r\n                'ApiKey': this.config.apiKey\r\n            }\r\n        });\r\n\r\n        return await response.json();\r\n    }\r\n\r\n    /**\r\n     * Sign in a user\r\n     *\r\n     * @param {*} username\r\n     * @returns\r\n     * @memberof PasswordlessClient\r\n     */\r\n    async signin(username) {\r\n        this.CheckSupport();\r\n        var options, sessionId;\r\n        try {\r\n            ({ data: options, sessionId } = await this.signinBegin(username));\r\n        } catch (e) {\r\n            console.warn(\"Failed during signin/begin\", e);\r\n            throw e;\r\n        }\r\n\r\n        options.challenge = coerceToArrayBuffer(options.challenge); //const challenge = makeAssertionOptions.challenge.replace(/-/g, \"+\").replace(/_/g, \"/\");\r\n\r\n        options.allowCredentials.forEach(function (listItem) {\r\n            listItem.id = coerceToArrayBuffer(listItem.id);\r\n        });\r\n\r\n        let credential;\r\n        try {\r\n            credential = await navigator.credentials.get({ publicKey: options })\r\n        } catch (e) {\r\n            console.warn(\"Failed during credentials.get in browser.\", e);\r\n            throw e;\r\n        }\r\n\r\n        try {\r\n            let response = await this.signinComplete(credential, sessionId);\r\n            return response.data;\r\n        } catch (e) {\r\n            console.warn(\"Failed during signin/complete\", e);\r\n            throw e;\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Internal function\r\n     */\r\n    async signinBegin(username) {\r\n        var res = await fetch(this.config.apiUrl + \"signin/begin\", {\r\n            method: 'POST',\r\n            body: JSON.stringify({\r\n                username: username,\r\n                ...this._params(),\r\n            }),\r\n            headers: {\r\n                'Accept': 'application/json',\r\n                'ApiKey': this.config.apiKey\r\n            }\r\n        });\r\n\r\n        return await res.json();\r\n    }\r\n\r\n    /**\r\n     * Internal function\r\n     */\r\n    async signinComplete(credential, sessionId) {\r\n\r\n        // Move data into Arrays incase it is super long\r\n        let authData = new Uint8Array(credential.response.authenticatorData);\r\n        let clientDataJSON = new Uint8Array(credential.response.clientDataJSON);\r\n        let rawId = new Uint8Array(credential.rawId);\r\n        let sig = new Uint8Array(credential.response.signature);\r\n        \r\n        const data = {\r\n            id: credential.id,\r\n            rawId: coerceToBase64Url(rawId),\r\n            type: credential.type,\r\n            extensions: credential.getClientExtensionResults(),\r\n            response: {\r\n                authenticatorData: coerceToBase64Url(authData),\r\n                clientDataJson: coerceToBase64Url(clientDataJSON),\r\n                signature: coerceToBase64Url(sig)\r\n            }\r\n        };\r\n\r\n        var res = await fetch(this.config.apiUrl + \"signin/complete\", {\r\n            method: 'POST',\r\n            body: JSON.stringify({\r\n                response: data,\r\n                sessionId: sessionId,\r\n                ...this._params(),\r\n            }),\r\n            headers: {\r\n                'Accept': 'application/json',\r\n                'ApiKey': this.config.apiKey\r\n            }\r\n        });\r\n\r\n        return await res.json();\r\n    }\r\n\r\n    /**\r\n     * Internal function\r\n     */\r\n    _params() {\r\n        return {\r\n            RPID: this.config.RPID,\r\n            Origin: this.config.Origin\r\n        }\r\n    }    \r\n}\r\n\r\ncoerceToArrayBuffer = function (thing) {\r\n    if (typeof thing === \"string\") {\r\n        // base64url to base64\r\n        thing = thing.replace(/-/g, \"+\").replace(/_/g, \"/\");\r\n\r\n        // base64 to Uint8Array\r\n        var str = window.atob(thing);\r\n        var bytes = new Uint8Array(str.length);\r\n        for (var i = 0; i < str.length; i++) {\r\n            bytes[i] = str.charCodeAt(i);\r\n        }\r\n        thing = bytes;\r\n    }\r\n\r\n    // Array to Uint8Array\r\n    if (Array.isArray(thing)) {\r\n        thing = new Uint8Array(thing);\r\n    }\r\n\r\n    // Uint8Array to ArrayBuffer\r\n    if (thing instanceof Uint8Array) {\r\n        thing = thing.buffer;\r\n    }\r\n\r\n    // error if none of the above worked\r\n    if (!(thing instanceof ArrayBuffer)) {\r\n        throw new TypeError(\"could not coerce to ArrayBuffer\");\r\n    }\r\n\r\n    return thing;\r\n};\r\n\r\n\r\ncoerceToBase64Url = function (thing) {\r\n    // Array or ArrayBuffer to Uint8Array\r\n    if (Array.isArray(thing)) {\r\n        thing = Uint8Array.from(thing);\r\n    }\r\n\r\n    if (thing instanceof ArrayBuffer) {\r\n        thing = new Uint8Array(thing);\r\n    }\r\n\r\n    // Uint8Array to base64\r\n    if (thing instanceof Uint8Array) {\r\n        var str = \"\";\r\n        var len = thing.byteLength;\r\n\r\n        for (var i = 0; i < len; i++) {\r\n            str += String.fromCharCode(thing[i]);\r\n        }\r\n        thing = window.btoa(str);\r\n    }\r\n\r\n    if (typeof thing !== \"string\") {\r\n        throw new Error(\"could not coerce to string\");\r\n    }\r\n\r\n    // base64 to base64url\r\n    // NOTE: \"=\" at the end of challenge is optional, strip it off here\r\n    thing = thing.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=*$/g, \"\");\r\n\r\n    return thing;\r\n};"],"names":["PasswordlessClient","[object Object]","apiUrl","apiKey","Origin","location","origin","RPID","hostname","config","this","PublicKeyCredential","isUserVerifyingPlatformAuthenticatorAvailable","undefined","window","isSupportedByBrowser","Error","token","options","session","newCredential","CheckSupport","data","sessionId","registerBegin","e","console","error","challenge","coerceToArrayBuffer","user","id","excludeCredentials","map","c","authenticatorSelection","authenticatorAttachment","navigator","credentials","create","publicKey","warn","registerComplete","response","fetch","method","body","JSON","stringify","_params","headers","Accept","Content-Type","ApiKey","json","attestationObject","Uint8Array","clientDataJSON","rawId","coerceToBase64Url","type","extensions","getClientExtensionResults","AttestationObject","clientDataJson","username","signinBegin","credential","allowCredentials","forEach","listItem","get","signinComplete","res","authData","authenticatorData","sig","signature","thing","replace","str","atob","bytes","length","i","charCodeAt","Array","isArray","buffer","ArrayBuffer","TypeError","from","len","byteLength","String","fromCharCode","btoa"],"mappings":"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"}