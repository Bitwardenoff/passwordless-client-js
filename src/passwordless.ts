import {
  AtLeast,
  PromiseResult,
  RegisterBeginResponse,
  RegisterCompleteResponse, SigninBeginResponse,
  SigninMethod,
  SigninResponse
} from './types';

export interface Config {
    apiUrl: string;
    apiKey: string;
    origin: string;
    rpid: string;
}


export class Client {
    private config: Config = {
        apiUrl: 'https://v3.passwordless.dev',
        apiKey: '',
        origin: window.location.origin,
        rpid: window.location.hostname,
    }
    private abortController: AbortController = new AbortController();

    constructor(config: AtLeast<Config, 'apiKey'>) {
        Object.assign(this.config, config);
    }

    /**
     * Register a new credential to a user
     *
     * @param {string} token Token generated by your backend and the Passwordless API
     */
    public async register(token: string, credentialNickname: string): PromiseResult<void> {
        this.assertBrowserSupported();

        try {
            const registration = await this.registerBegin(token);

            registration.data.challenge = base64UrlToArrayBuffer(registration.data.challenge);
            registration.data.user.id = base64UrlToArrayBuffer(registration.data.user.id);
            registration.data.excludeCredentials?.forEach((cred) => {
                cred.id = base64UrlToArrayBuffer(cred.id);
            });

            const credential = await navigator.credentials.create({
                publicKey: registration.data,
            }) as PublicKeyCredential;

            if (!credential) {
                throw new Error('Failed to create credential (navigator.credentials.create)');
            }

            await this.registerComplete(credential, registration.sessionId, credentialNickname);
        } catch (error: any) {
            console.error(error);
            throw new Error(`Passwordless register failed: ${error.message}`);
        }
    }

    /**
     * Sign in a user using the userid
     * @param {string} userId
     * @returns
     */
    public async signinWithId(userId: string): PromiseResult<SigninResponse> {
        return this.signin({userId})
    }

    /**
     * Sign in a user using an alias
     * @param {string} alias
     * @returns a verify_token
     */
    public async signinWithAlias(alias: string): PromiseResult<SigninResponse> {
        return this.signin({alias})
    }

    /**
     * Sign in a user using autofill UI (a.k.a conditional) sign in
     * @returns a verify_token
     */
    async signinWithAutofill(): PromiseResult<SigninResponse> {
        if (!await isAutofillSupported()) {
            throw new Error("Autofill authentication (conditional meditation) is not supported in this browser");
        }
        return this.signin({autofill: true});
    }

    abort() {
        if (this.abortController) {
            this.abortController.abort();
        }
    }

    private async registerBegin(token: string): Promise<RegisterBeginResponse> {
        const response = await fetch(`${this.config.apiUrl}/register/begin`, {
            method: 'POST',
            headers: this.createHeaders(),
            body: JSON.stringify({
                token,
                RPID: this.config.rpid,
                Origin: this.config.origin,
            }),
        });

        return response.json();
    }

    private async registerComplete(
        credential: PublicKeyCredential,
        sessionId: string,
        credentialNickname: string,
    ): Promise<RegisterCompleteResponse> {
        const attestationResponse = credential.response as AuthenticatorAttestationResponse;

        const response = await fetch(`${this.config.apiUrl}/register/complete`, {
            method: 'POST',
            headers: this.createHeaders(),
            body: JSON.stringify({
                sessionId,
                response: {
                    id: credential.id,
                    rawId: arrayBufferToBase64Url(credential.rawId),
                    type: credential.type,
                    extensions: credential.getClientExtensionResults(),
                    response: {
                        AttestationObject: arrayBufferToBase64Url(
                            attestationResponse.attestationObject
                        ),
                        clientDataJson: arrayBufferToBase64Url(
                            attestationResponse.clientDataJSON
                        ),
                    },
                },
                nickname: credentialNickname,
                RPID: this.config.rpid,
                Origin: this.config.origin,
            }),
        });

        return response.json();
    }

    /**
     * Sign in a user
     *
     * @param {SigninMethod} Object containing either UserID or Alias
     * @returns
     */
    private async signin(signinMethod: SigninMethod): PromiseResult<SigninResponse> {
        this.assertBrowserSupported();
        this.handleAbort();

        try {
            const signin = await this.signinBegin(signinMethod);

            signin.data.challenge = base64UrlToArrayBuffer(signin.data.challenge);
            signin.data.allowCredentials?.forEach((cred) => {
                cred.id = base64UrlToArrayBuffer(cred.id);
            });

            const credential = await navigator.credentials.get({
                publicKey: signin.data,
                mediation: 'autofill' in signinMethod ? "conditional" as CredentialMediationRequirement : undefined, // Typescript doesn't know about 'conditational' yet
                signal: this.abortController.signal,
            }) as PublicKeyCredential;

            const response = await this.signinComplete(credential, signin.sessionId);
            
            return response;
        } catch (error: any) {
            console.error(error);
            throw new Error(`Passwordless signin failed: ${error.message}`);
        }
    }

    private async signinBegin(signinMethod: SigninMethod): PromiseResult<SigninBeginResponse> {
        const response = await fetch(`${this.config.apiUrl}/signin/begin`, {
            method: 'POST',
            headers: this.createHeaders(),
            body: JSON.stringify({
                userId: "userId" in signinMethod ? signinMethod.userId : undefined,
                alias: "alias" in signinMethod ? signinMethod.alias : undefined,
                RPID: this.config.rpid,
                Origin: this.config.origin,
            }),
        });

        return response.json();
    }

    private async signinComplete(
        credential: PublicKeyCredential,
        sessionId: string,
    ): PromiseResult<SigninResponse> {
        const assertionResponse = credential.response as AuthenticatorAssertionResponse;

        const response = await fetch(`${this.config.apiUrl}/signin/complete`, {
            method: 'POST',
            headers: this.createHeaders(),
            body: JSON.stringify({
                sessionId,
                response: {
                    id: credential.id,
                    rawId: arrayBufferToBase64Url(new Uint8Array(credential.rawId)),
                    type: credential.type,
                    extensions: credential.getClientExtensionResults(),
                    response: {
                        authenticatorData: arrayBufferToBase64Url(
                            assertionResponse.authenticatorData,
                        ),
                        clientDataJson: arrayBufferToBase64Url(
                            assertionResponse.clientDataJSON
                        ),
                        signature: arrayBufferToBase64Url(
                            assertionResponse.signature
                        ),
                    },
                },
                RPID: this.config.rpid,
                Origin: this.config.origin,
            }),
        });

        const res = await response.json();
        if(response.ok) {
            return res;
        }
        
        return { token: undefined, error: res}
    }

    private handleAbort() {
        this.abort();
        this.abortController = new AbortController();
    }

    private assertBrowserSupported(): void {
        if (!isBrowserSupported()) {
            throw new Error('WebAuthn and PublicKeyCredentials are not supported on this browser/device');
        }
    }

    private createHeaders(): Record<string, string> {
        return {
            ApiKey: this.config.apiKey,
            'Content-Type': 'application/json',
        };
    }

    

    
    

   

    public isPlatformSupported(): Promise<boolean> {
        return isPlatformSupported();    
    }
    
    public isBrowserSupported(): boolean {
        return isBrowserSupported();
    }

    public isAutofillSupported(): Promise<boolean> {
        return isAutofillSupported();
    }
}

export async function isPlatformSupported(): Promise<boolean> {
    if (!isBrowserSupported()) return false;
    return PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();
}

export function isBrowserSupported(): boolean {
    return window.PublicKeyCredential !== undefined && typeof window.PublicKeyCredential === 'function';
}

export async function isAutofillSupported(): Promise<boolean> {
    const PublicKeyCredential = window.PublicKeyCredential as any; // Typescript lacks support for this
    if (!PublicKeyCredential.isConditionalMediationAvailable) return false;
    return PublicKeyCredential.isConditionalMediationAvailable() as Promise<boolean>;
}

function base64ToBase64Url(base64: string): string {
    return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=*$/g, '');
}

function base64UrlToBase64(base64Url: string): string {
    return base64Url.replace(/-/g, '+').replace(/_/g, '/');
}

function base64UrlToArrayBuffer(base64UrlString: string | BufferSource): ArrayBuffer {
    // improvement: Remove BufferSource-type and add proper types upstream
    if (typeof base64UrlString !== 'string') {
        const msg = "Cannot convert from Base64Url to ArrayBuffer: Input was not of type string";
        console.error(msg, base64UrlString);
        throw new TypeError(msg);
    }

    const base64Unpadded = base64UrlToBase64(base64UrlString);
    const paddingNeeded = (4 - (base64Unpadded.length % 4)) % 4;
    const base64Padded = base64Unpadded.padEnd(base64Unpadded.length + paddingNeeded, "=");

    const binary = window.atob(base64Padded);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
    }

    return bytes;
}

function arrayBufferToBase64Url(buffer: ArrayBuffer | Uint8Array): string {
    const uint8Array = (() => {
        if (Array.isArray(buffer)) return Uint8Array.from(buffer);
        if (buffer instanceof ArrayBuffer) return new Uint8Array(buffer);
        if (buffer instanceof Uint8Array) return buffer;

        const msg = "Cannot convert from ArrayBuffer to Base64Url. Input was not of type ArrayBuffer, Uint8Array or Array";
        console.error(msg, buffer);
        throw new Error(msg);
    })();

    let string = '';
    for (let i = 0; i < uint8Array.byteLength; i++) {
        string += String.fromCharCode(uint8Array[i]);
    }

    const base64String = window.btoa(string);
    return base64ToBase64Url(base64String);
}
